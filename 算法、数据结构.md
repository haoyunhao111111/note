```python
# 0-1000  a,b,c   a+b+c=1000 并且 a^2+b^2=c^2  求a,b,c

# for a in range(1001):
#     for b in range(1001):
#         for c in range(1001):
#             if (a+b+c==1000 and a*a+b*b==c*c):
#                 print(a,b,c)
T(n)=O(n^3)

for a in range(1001):
    for b in range(1001):
        c=1000-a-b
        if (a*a+b*b==c*c):
            print(a,b,c)
T(n)=O(n^2)
# 求指定数字以内的所有素数

def aa(num):
    arr=[1]
    for a in range(2,num+1):
        for b in range(2,a):
            if a%b==0:
                break
        else:
            arr.append(a)
    print(arr)

aa(101)
```

## 算法

### 五大特性

有穷性  确切性  输入项  输出项  可行性

### 衡量算法的优劣

#### 时间复杂度

> 程序执行的步骤数量

顺序结构   加法  

循环结构  乘法

分支结构   最大可能性的步骤



大O计数法：常数忽略不计



##### 消耗时间从小到大

O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2*n)<O(n!)<O(n^n)

#### 空间复杂度



### python内置类型性能分析

#### timeit模块

> 准确测量一小段代码的执行时间

```python
timeit.timeit('cc()',setup="from __main__ import cc",number=10000)
```

### 迭代对象

> 字符串、列表、字典、集合都是迭代对象

```python
from collections import Iterable
print(isinstance("abc",Iterable))
```

### 迭代器

```python
class aa:
    def __init__(self):
        self.datas=["a","b","c"]
        self.index=0
    def __iter__(self):
        return self
    def __next__(self):
        if self.index<len(self.datas):
            val=(self.datas[self.index])
            self.index+=1
            return val
        else:
            raise StopIteration
```

### 生成器  协程

```python
aa=(i for i in range(10))
for item in aa:
    print(item)
```

#### yield

> 把函数返回的内容，装进生成器对象里面   <generator object>

```python
def qq(num):
    a,b,c=0,1,0
    c = 0
    while c < num:
        yield b
        a, b = b, a + b  # a=b   b=a+b
        c += 1
print(list(qq(10)))
```

#### yield(协程)

```python
import time
def aa():
    while True:
        yield
        print("我是aa")
        time.sleep(1)
def bb():
    while True:
        yield
        print("bb")
        time.sleep(1)
        
aa=aa()
bb=bb()
while True:
    next(aa)
    next(bb)
```



