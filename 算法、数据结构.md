```python
# 0-1000  a,b,c   a+b+c=1000 并且 a^2+b^2=c^2  求a,b,c

# for a in range(1001):
#     for b in range(1001):
#         for c in range(1001):
#             if (a+b+c==1000 and a*a+b*b==c*c):
#                 print(a,b,c)
T(n)=O(n^3)

for a in range(1001):
    for b in range(1001):
        c=1000-a-b
        if (a*a+b*b==c*c):
            print(a,b,c)
T(n)=O(n^2)
# 求指定数字以内的所有素数

def aa(num):
    arr=[1]
    for a in range(2,num+1):
        for b in range(2,a):
            if a%b==0:
                break
        else:
            arr.append(a)
    print(arr)

aa(101)
```

# 算法

### 五大特性

有穷性  确切性  输入项  输出项  可行性

### 衡量算法的优劣

#### 时间复杂度

> 程序执行的步骤数量

顺序结构   加法  

循环结构  乘法

分支结构   最大可能性的步骤

大O计数法：近似函数值，常数忽略不计

##### 消耗时间从小到大

O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2*n)<O(n!)<O(n^n)

#### 空间复杂度



### python内置类型性能分析

#### timeit模块

> 准确测量一小段代码的执行时间

```python
timeit.timeit('cc()',setup="from __main__ import cc",number=10000)
```

### 迭代对象

> 字符串、列表、字典、集合都是迭代对象

```python
from collections import Iterable
print(isinstance("abc",Iterable))
```

### 迭代器

```python
class aa:
    def __init__(self):
        self.datas=["a","b","c"]
        self.index=0
    def __iter__(self):
        return self
    def __next__(self):
        if self.index<len(self.datas):
            val=(self.datas[self.index])
            self.index+=1
            return val
        else:
            raise StopIteration
            
                     
arr=aa()
for item in arr:
    print(item)
```

### 生成器  协程

```python
aa=(i for i in range(10))
for item in aa:
    print(item)
```

#### yield

> 把函数返回的内容，装进生成器对象里面   <generator object>

```python
def qq(num):
    a,b,c=0,1,0
    c = 0
    while c < num:
        yield b
        a, b = b, a + b     # a=b   b=a+b
        c += 1
print(list(qq(10)))
```

#### yield(协程)

```python
import time
def aa():
    while True:
        yield
        print("我是aa")
        time.sleep(1)
def bb():
    while True:
        yield
        print("bb")
        time.sleep(1)
        
aa=aa()
bb=bb()
while True:
    next(aa)
    next(bb)
```

# 数据结构

> 计算机存储，组织数据的方式，数据结构是指相互之间存在一种或多种特定关系的数据元素的集合

### 数据结构和算法的区别

数据结构只是静态的描述了数据元素之间的关系

高效的程序需要在数据结构的基础上设计和选择算法

**程序=数据结构+算法**

### 顺序表

> 适合做索引查找

python分离式技术实现动态顺序表

```python
def match1(str1):
    con = "(){}[]"
    arr = []
    for item in str1:
        if con.find(item) == -1:
            continue
        if item == "{" or item == "[" or item == "(":
            arr.append(item)
            continue

        if len(arr) == 0:
            return False
        val = arr.pop()
        if (val == "(" and item == ")") or (val == "{" and item == "}") or (val == "[" and item == "]"):
            continue
        else:
            return False

    if len(arr) > 0:
        return False
    else:
        return True


print(match1("[sdji(dfw){sd(sfj)pk}]"))
```









显示方式：0(默认值)  1（高亮）  22（非粗体）  4（下划线）  24（非下划线）  5（闪烁）   25（非闪烁）   7（反显）   27（非反显）



前景色   30（黑色）  31（红色）   32（绿色）  33（黄色）  34（蓝色）  35（洋红）  36（青色）    37（白色）

 

背景色   40（黑色）  41（红色）   42（绿色）  43（黄色）  44（蓝色）  45（洋红）  46（青色）    47（白色） 





###### ![](C:\Users\hyh\Desktop\note\20181123172624.png)



递归算法的空间复杂度：递归深度N*每次递归所要的辅助空间   





## 排序：

![](C:\Users\hyh\Desktop\note\paixu.jpg)



### 冒泡排序

```python
def sort(a):
    for x in range(0,len(a)-1):
        for y in range(x+1,len(a)):
            if a[x]>a[y]:
                c=a[x]
                a[x]=a[y]
                a[y]=c
    return a
a=[2,34,6,35,12,54,78,98,7,9]
print(sort(a))

arr=[2,34,6,35,12,54,78,98,7,9]
for i in range(len(arr)):
    for j in range(len(arr)-1):
        if arr[j]>arr[j+1]:
            arr[j],arr[j+1]=arr[j+1],arr[j]
print(arr)
```



### 选择排序

```python
arr=[2,34,6,35,12,54,78,98,7,9]
for i in range(len(arr)-1):
    min=i
    for j in range(i,len(arr)):
        if arr[j]<arr[min]:
            min=j
    arr[i],arr[min]=arr[min],arr[i]

print(arr)
```



### 插入排序

```python
arr1=[2,34,6,35,12,54,78,98,7,9]
for i in range(len(arr1)):
    pre=i-1
    current=arr1[i]
    while pre>=0 and current<arr1[pre]:
        arr1[pre+1]=arr1[pre]
        pre-=1
    arr1[pre+1]=current
print(arr1)
```



### 快速排序

```python
def quick(arr,start,end):
    if start>end:
        return
    left=start
    right=end
    temp=arr[left]
    while left<right:
        while left<right and temp<arr[right]:
            right-=1
        # arr[left]=arr[right]
        while left < right and temp > arr[left]:
            left += 1
        # arr[right]=arr[left]
        arr[left],arr[right]=arr[right],arr[left]
    arr[left],temp=temp,arr[left]
    # arr[left]=temp
    quick(arr,start,left-1)
    quick(arr, left+1, end)

arr=[2,34,6,35,12,54,78,98,7,9]
quick(arr,0,len(arr)-1)
print(arr)
```



### 希尔排序

```python
arr1=[2,34,6,35,12,54,78,98,7,9]
leng=len(arr1)
val=leng//2
while val>0:
    for i in range(val,leng):
        pre=i-1
        current=arr1[i]
        while pre>=0 and current<arr1[pre]:
            arr1[pre+1]=arr1[pre]
            pre-=1
        arr1[pre+1]=current
    val=val//2
print(arr1)
```



### 堆排序

```python
arr=[20,34,6,35,12,54,78,98,7,9]
def big(arr,start,length):
    next = start * 2 + 1
    while next<length:
        if next+1<length and arr[next]<arr[next+1]:
            next+=1
        if arr[start]<arr[next]:
            arr[start],arr[next]=arr[next],arr[start]
            start=next
        else:
            break
        next = start * 2 + 1

for i in range(len(arr)//2-1,-1,-1):
    big(arr,i,len(arr))

for i in range(len(arr)-1,-1,-1):
    arr[i],arr[0]=arr[0],arr[i]
    big(arr, 0,i)

print(arr)
```



### 计数排序

### 桶序

```python
arr=[2,34,6,35,12,54,78,98,7,9]
big=arr[0]
for item in arr:
    if big<item:
        big=item
tong=[0]*(big+1)
for i in arr:
    tong[i]+=1

arr1=[]
for index in range(len(tong)):
    if tong[index]!=0:
        for item in range(tong[index]):
            arr1.append(index)
arr=arr1
print(arr)
```



### 基数排序



## 树

- 节点的度：一个节点含有的子树的个数称为该节点的度
- 树的度：最大的节点的度
- 叶节点：度为0的节点

### 种类

- 无序树
- 有序树：树种任意节点之间有顺序关系
  - 二叉树：每个节点最多包含两个子节点
    - 完全二叉树：对于一个二叉树，假设其深度为d(d>0)；除d层外，其他各层的节点都达到了最大，d层所有节点        都集中在最左边
    - 平衡二叉树：空树或者左右两个子节点的高度差绝对值不超过1
    - 排序二叉树
      - 若左子树不空，则左子树上每个节点的值均小于根节点的值
      - 若右子树不空，则右子树上每个节点的值均大于根节点的值
      - 左，右子树也分别为二叉排序树
      - 没有键值相等的节点
    - 霍夫曼树：带权路径最短的二叉树
    - B树

### 深度优先

1. 先序：根->左->右
2. 中序：左->根->右
3. 后序：左->右->根

### 二叉树的性质

- 在二叉树的第i层上最多有2^(i-1)个节点  (i>0)
- 深度为k的二叉树至多有2^k-1个结点(k>0)
- 任意一棵二叉树，叶结点树为n,度数为2的结点总数为m,则n-m=1
- 具有n个结点的完全二叉树的深度必为(logn)+1，取整数
- 完全二叉树，若从上到下，从左到右编号，则编号为i的结点，其左孩子编号为2i+1，右孩子编号为2i+2,双亲编号为i/2-1（i从0开始）
- 完全二叉树，最后一个非叶子结点的下标是n/2-1（向下取整）

### 查找

二分查找；前提是排序完成的

> ord("a")   chr(ord("a"))   encode    int.from_bytes()

- 递归

```python
def find(arr,item):
    if arr==[]:
        return False
    middle=len(arr)//2
    if arr[middle]==item:
        return True
    if item<arr[middle]:
        return find(arr[:middle],item)
    else:
        return find(arr[middle+1:],item)
arr=[6,7,9,12,20,34,35,54,78,98]
print(find(arr,7))
```

- 循环

```python
def find1(arr,item):
    if arr==[]:
        return False
    left=0
    right=len(arr)-1
    while left<=right:
        middle=(left+right)//2
        if arr[middle]==item:
            return True
        elif item<arr[middle]:
            right=middle-1
        else:
            left=middle+1
    return False

print(find1(arr,12))
```

